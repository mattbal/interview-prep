# Sliding Window

**Problem Type:** Calculate or Find X of subarrays, sublists, or substrings.

**Data Structures:** Arrays, LinkedLists, or Strings.

<br>

## **Pattern:**

Brute force:

> Given an array, calculate the average for each of its contiguous subarrays of size K

```C++

for(int i = 0; i < arr.size(); i++) {
  for(int j = i; j < i + K; i++) {
    // calculate average
  }
}

```

which is not efficient because we end up with an overlap:

```C++
where K = 3,

i = 0   0, 1, 2
i = 1      1, 2, 3
i = 2         2, 3, 4
```

Notice the overlap between 1 and 2. We're performing extra unnecessary calculations

<br>

How sliding window optimizes this:

> Given an array, calculate the average for each of its contiguous subarrays of size K

```C++
int windowSum = 0
int windowStart = 0

vector<int> sums;

for(int i = 0; i < arr.size(); i++) {
  windowSum += windowStart

  if (i >= K - 1) {
    // add window average to sums vector

    windowSum -= arr[windowStart]
    windowStart++
  }
}

return sums
```
which results in:

```C++
[0, 1, 2] // get to size K
[0, 1, 2, 3] // windowSum += windowStart step
[1, 2, 3] // windowSum -= arr[windowStart] step
```

The window slides to the right, then we subtract the first element to shrink the window. This takes the brute force solution's time complexity from O(N*K) to O(N)

## Problem 1

> Given an array and a number K, find the maximum sum of any of the contiguous subarrays of size K

Brute force:

```C++
int windowSum = 0
int maxSum = 0

for(int i = 0; i < arr.size(); i++) {
  windowSum = 0
  for(int j = i; j < i + K, j++) {
    windowSum += arr[j]
  }

  // ternary operator = C++ max function
  maxSum = maxSum < windowSum ? windowSum : maxSum
}

return maxSum
```

Optimal solution is to reuse the sum of the previous window

```C++
int maxSum = 0
int windowSum = 0
int windowStart = 0

for(int i = 0; i < arr.size(); i++) {
  windowSum += arr[i]

  if (i >= K - 1) {
    maxSum = maxSum < windowSum ? windowSum : maxSum

    windowSum -= arr[windowStart]
    windowStart++
  }
}

return maxSum
```

## Problem 2

> Given an array and a number S, find the length of the smallest contiguous subarray whose sum is greater than or equal to S

> Return 0 if no such subarray exists

```C++
#include <algorithm>

int windowStart = 0
int windowSum = 0
int minLength = INT_MAX

for(int i = 0; i < arr.size(); i++) {
  windowSum += arr[i]

  // since we're trying to find the smallest, once we find
  // a window that works, keep trying to shrink it as small as possible
  while(windowSum >= S) {
    minLength = std::min(minLength, i - windowStart + 1)

    windowSum -= arr[windowStart]
    windowStart++
  }
}

if (minLength == INT_MAX) return 0
```