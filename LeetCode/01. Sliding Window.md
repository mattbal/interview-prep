# Sliding Window

**Problem Type:** Calculate or Find X of subarrays, sublists, or substrings.

**Data Structures:** Arrays, LinkedLists, or Strings.

## Pattern

Brute force:

> Given an array, calculate the average for each of its contiguous subarrays of size K

```C++

for(int i = 0; i < arr.size(); i++) {
  for(int j = i; j < i + K; i++) {
    // calculate average
  }
}

```

which is not efficient because we end up with an overlap:

```C++
where K = 3,

i = 0   0, 1, 2
i = 1      1, 2, 3
i = 2         2, 3, 4
```

Notice the overlap between 1 and 2. We're performing extra unnecessary calculations

<br>

How sliding window optimizes this:

> Given an array, calculate the average for each of its contiguous subarrays of size K

```C++
int windowSum = 0
int windowStart = 0

vector<int> sums;

for(int i = 0; i < arr.size(); i++) {
  windowSum += windowStart

  if (i >= K - 1) {
    // add window average to sums vector

    windowSum -= arr[windowStart]
    windowStart++
  }
}

return sums
```
which results in:

```C++
[0, 1, 2] // get to size K
[0, 1, 2, 3] // windowSum += windowStart step
[1, 2, 3] // windowSum -= arr[windowStart] step
```

The window slides to the right, then we subtract the first element to shrink the window. This takes the brute force solution's time complexity from O(N*K) to O(N)

## Problem 1

> Given an array and a number K, find the maximum sum of any of the contiguous subarrays of size K

Brute force:

```C++
int windowSum = 0
int maxSum = 0

for(int i = 0; i < arr.size(); i++) {
  windowSum = 0
  for(int j = i; j < i + K, j++) {
    windowSum += arr[j]
  }

  // ternary operator = C++ max function
  maxSum = maxSum < windowSum ? windowSum : maxSum
}

return maxSum
```

Optimal solution is to reuse the sum of the previous window

```C++
int maxSum = 0
int windowSum = 0
int windowStart = 0

for(int i = 0; i < arr.size(); i++) {
  windowSum += arr[i]

  if (i >= K - 1) {
    maxSum = maxSum < windowSum ? windowSum : maxSum

    windowSum -= arr[windowStart]
    windowStart++
  }
}

return maxSum
```

## Problem 2

> Given an array and a number S, find the length of the smallest contiguous subarray whose sum is greater than or equal to S

> Return 0 if no such subarray exists

```C++
#include <algorithm>

int windowStart = 0
int windowSum = 0
int minLength = INT_MAX

for(int i = 0; i < arr.size(); i++) {
  windowSum += arr[i]

  // since we're trying to find the smallest, once we find
  // a window that works, keep trying to shrink it as small as possible
  while(windowSum >= S) {
    minLength = std::min(minLength, i - windowStart + 1)

    windowSum -= arr[windowStart]
    windowStart++
  }
}

if (minLength == INT_MAX) return 0
```

## Problem 3

> Given a string, find the length of the longest substring in it with no more than K distinct characters. Assume K is less than or equal to the length of the string.

```C++
#include <unordered_map>
#include <algorithm> // std::max

int windowStart = 0
int maxLength = 0
std::unordered_map<char, int> umap;

for(int i = 0; i < str.length(); i++) {
  char c = str[i]
  if (umap.find(c) == umap.end()) {
    // not found
    umap[c] = 0
  }
  umap[c]++;

  // once our window becomes > K, we have to shrink it.
  while(umap.size() > k) {
    // decrease the count for the char we're removing
    char startChar = str[windowStart]
    umap[starChar]--
    if (umap[startChar] == 0) {
      umap.erase(startChar)
    }
    windowStart++
  }
  // update maxLength
  maxLength = std::max(maxLength, i - windowStart + 1)
}

return maxLength
```

## Problem 4

> Given an array of characters where each character represents a fruit tree, you are given two baskets and your goal is to put the maximum amount of fruit in each basket. The only restriction is that each basket can only have one type fruit.

> You can start with any tree, but you can't skip a tree once you have started. You will pick one fruit from each tree until you cannot (when you have to pick from a third fruit type)

```C++
#include <unordered_map>
#include <algorithm> // std::max

int windowStart = 0
int windowMax = 0
std::unordered_map<int, int> fruitMap;

for(int i = 0; i < fruits.length(); i++) {
  int endFruit = fruits[i]

  // if endFruit doesn't exist, it will be added and initialized to 0
  int x = fruitMap[endFruit]
  x++;

  // shrink the window
  while(fruitMap.size() > 2) {
    int startFruit = fruits[windowStart]
    x = fruitMap[startFruit]
    x--

    if (fruitMap[startFruit] == 0) {
      fruitMap.erase(startFruit)
    }
    windowStart++
  }

  windowMax = std::max(windowMax, i - windowStart + 1)
}

std::cout << "maximum number of trees: " << windowMax << "\n"
std::cout << "From index " << windowStart << " to index " << windowStart + windowMax << "\n"
```

## Problem 5

> Given a string, find the length of the longest substring in it with at most two distinct characters

```C++
#include <unordered_map>
#include <algorithm>

int windowStart = 0
unordered<char, int> umap;
int maxLength = 0

for(int i = 0; i < s.size(); i++) {
  if (umap.find(s[i]) == umap.end()) {
    umap[s[i]] = 0
  }
  umap[s[i]]++

  // keep expanding the umap until it reaches size 3, then we 
  // shrink it back to two distinct characters
  while (umap.size() > 2) {
    // Option 1 for shrinking window
    umap[s[windowStart]]--;
    if (umap[s[windowStart]] == 0) {
      umap.erase(s[windowStart])
    }
    windowStart++

    // Option 2
    // char c = s[windowStart];
		// windowStart += umap[c];
		// umap.erase(c);
    
    /* 
      This handles scenario where we would keep doing loops over
      and over again to shrink only by 1 at a time.

      AAAAABBBBC <- C, triggers while loop to execute
      AAAABBBBC
      ...
      BBBBC

		*/
  }

  maxLength = std::max(maxLength, i - windowStart + 1)
}

return maxLength
```

## Problem 6

> Given a string, find the length of the longest substring which has no repeating characters

```C++
#include <unordered_map>
#include <algorithm>

int windowStart = 0
int maxLength = 0
unordered_map<char, int> umap;

for(int i = 0; i < s.size(); i++) {
  if (umap.find(s[i]) != umap.end()) {
    windowStart = std::max(windowStart, umap[s[i]] + 1)
  }
  umap[s[i]] = i;
  maxLength = std::max(maxLength, i - windowStart + 1);
}

return maxLength
```